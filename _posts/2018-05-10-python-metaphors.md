---
layout: post
title: "Python Metaphors and their explainations"
comments: true
description: "Based on the talk by James Powell"
keywords: "python decorators metaclasses generators context-managers"
---


A context manager is merely some piece of code that pairs setup and teardown actions so the teardown action always occurs if the setup action occurred a generator is merely some form of syntax that allows us to do things like enforce sequencing and interleaving notice the context manager requires interleaving because it's set up is interleaved with the actual action you do in the block you do the setup then the action in the block and the teardown at the end there is that sequencing where the set up the enter has to be done before the exit so it makes sense to have a generator here as well finally we need something to adapt the generator to this data model that we looked at at the very beginning we have these underscore methods and we have to find some way to take how the generator works and fit it into those underscore methods one of the things we need to do in order to do that is we need to take this generator object to wrap it in some fashion that wrapping is part of the core of how Python works it's easy to dynamics and construct functions and have those functions wrap other functions that's part of the core language itself it's not really something that we could even lift the level of being a feature it really is core to how Python itself is written however there does happen to be a feature called decorators that allows us a nice convenient syntax for doing that exactly. 

So what you can see here is an example of everything except metaclasses and how they all fit together and how some of these core pieces of Python fit together to write what you might consider to be more nearly expert level code what I can tell you is that in Python expert level code is not code that uses every single feature it's in fact not code that even uses that many features of Python it's code that has a certain clarity to where and when a feature should be used it's code that doesn't waste the time of the person who's writing it because they say to themselves I have this pattern Python has this mechanism I fit them together and everything just seamlessly and and very smoothly works it's code that doesn't have a lot of additional mechanisms associated with it it doesn't have people creating their own protocols

What is far more important and then the names of the arguments that get pass to exit or the specific fashion in which different numeric underscore methods get dispatched whether you do our add or or add depending on which is the most derived class all of those details are actually secondary to a core conceptual understanding of what these feature mean what these features mean so what 

I can tell you as the real lessons from this is as follows "Python is a language orientated around protocols" there's some behavior some syntax some bytecode or some top-level function and there's a way for you to tell Python how to implement that on an arbitrary object the underscore methods that exact correspondence is usually guessable but if you can't guess it Google Python data model and you'll find all the different methods and all the caveats of their use Python is a very simple simplistic language in terms of his execution model code runs from top to bottom and things which would not be executable statements in other languages like class statements and function definitions or generate definitions are actually executable code in Python because they're executable code not only can you do things like hook into them but you can also do things like define functions within functions based off of runtime data define classes within functions based off of some runtime information you have how these impact specific features metaclasses 

Metaclass is merely some hook in a class construction process because classes are constructed at runtime you can hook code in there and be you can hook into the creation of subclasses you can ask the subclass certain questions like do you have these methods implemented implemented that's what they do that's the mechanism but the meeting behind it is quite simple you have library code and user code when you sit on the library author side how do you make sure the users don't screw up how do you enforce a good straight from the library code to the user code well all that it takes is some way talk into the process of how user code user classes are instantiated that's merely with the meta classes you find that place where you add that hook you add the check that you want Oh make sure that you have the bar method implemented and you solve the problem in fact in the Python standard library there are regularize solutions to problems like that in collections of ABC there is an ABC meta class it allows you to use decorators to mark certain methods and abstract methods so you don't have to write the metaclass yourself and you can think this is a pattern of what the meta class is doing in fact almost every example of a meta class that you'll see will be this pattern of some base class and some derived class the base class trying to enforce the constraint on the derived class it's almost every pattern of the meta class that you'll see where that meta classes are justified of course you can misuse them to do all sorts of crazy things you can use them in places where it doesn't make any sense but in the justified uses of the metaclass that's what it's all about.

For the decorator it really incidentally that interesting just a little bit of syntax to allow you to write one line of code a little bit nicer to take one line of code that you write after your function definition and put it above your function definition when it hooks into this idea in Python that everything gets clear at runtime so that when you combine that with the ability to define functions within functions you can use this in order to wrap sets of functions with some before and after behavior if you're been around long enough you might think you might recall this was the whole aspect orientated idea but the idea that can I take a function and wrap it with some behavior such as timing you know capturing the time before capture the time after or doing things like authentication or logging anything where you don't have to go it's the function itself you just wrap the behavior around it.

Generators are merely a way to take a single computation that would otherwise run eagerly from the insert from the injection of its parameters to the final computation and interleaving with other code by adding yield points where you can yield the temp the intermediate result values or one small piece of the computation and also yield control back to the caller in that vein you can think of a generator as being a way to take one long piece of one long computation and break it up in small parts where the computation can run a small sub sub unit of that computation but your user click and step in and do whatever it wants maybe it will use a partial value or use one of the first return values if you're returning a sequence of return values you might use the each of the individual values and in that fashion you can have greater control over how much of that how much of that computation actually runs do you run it all the way to completion or do need to run it to gab the first five values you need you also have greater control over how much memory is used because the generator can just yield the value back to you and you can choose which of those return values you want to keep which of the do you want to throw away context managers are merely some structure for allowing you to tie two actions together a set up action and a teardown action and make sure they always happen in concordance with each other if the set up action occurs make sure that teardown action occurs even if some error happens in the middle now.

When you think about these features and you realize they're related but mostly orthogonal you can combine them in interesting ways like you see in this example here where you have a decorator a context manager and a generator all coexisting and serving exactly it's one purpose as I said at the very beginning the syntax doesn't matter the details won't matter until you need to use them what I want to leave you with especially since a lot of you are not already very fluent Python programmers I want to leave you with this idea remember what these features are about remember what they're for that's something that you should be able to remember longer than the exact details of the syntax or even to details in fact the implementation details the details on syntax will change over time some of the flaws of the ability ssin make it fixed other details will be fixed another fashion but the core meaning behind these is something that will last and will guide you towards writing expert level Python code far better than memorizing just a bunch of features ever will.
